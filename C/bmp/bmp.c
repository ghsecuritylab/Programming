/* xres = 160 */
/* yres = 160 */
uint8_t fp[160 * 160 / 8];

#define BMP_HEIGHT 80
#define BMP_WIDTH  80

uint8_t videoram_get_pixel(int x, int y, uint8_t *buf, uint8_t *index)
{
#define COLORS	2 /* BLACK && WHITE */
	uint8_t data;
	uint8_t byte;
	unsigned int off;

	off = y * LCD_BPP1_BYTESPERLINE + ((x) >> 3);
	byte = *(buf + off);
	*index = (byte >> (7 - (x & 7))) & 1;
	*index = COLORS -1 - *index;

	data = 0x80 >> ((x & 7));

	return data;
}

uint8_t bitmap_get_pixel(int x, int y, uint8_t *bmp, int bmp_width)
{
	/* #define MONO01 */ /* 1=Black 0=White */

	/* Keep consistent with Qemu */
	#define MONO10 /* 1=White 1=Black */

	uint8_t  data;
	uint8_t  byte;
	unsigned int off;
	uint8_t	 xor;
	uint8_t bmp_line_len;

#ifdef MONO10
	xor = 0x0;
#else
	xor = 0xFF;
#endif

	bmp_line_len = (bmp_width + 7) >> 3;
	off = y * bmp_line_len + ((x) >> 3);

	byte = *(bmp + off);
	byte = byte ^ xor;

	data = (byte >> (7 - (x & 7))) & 1;
	return data;
}

void videoram_set_pixel(int x, int y, int c, uint8_t *buf)
{
	unsigned int off;
	uint8_t pix;
	
	pix = x & 7;
	off = y * LCD_BPP1_BYTESPERLINE + ((x)>>3);

	c = c & 1;

	if ( c == 1) {
		*(buf + off) |= 1 << (7 - pix);
	} else if (c == 0) {
		*(buf + off) &= ~ (1 << (7 - pix));
	}
}

/* bmp buffer read through fread */
void show_bitmap()
{
	/* target os need 1BPP */
#define BMP_FILE_SIZE (BMP_HEIGHT * BMP_WIDTH / 8)
	int i, j;
	uint8_t bmp_line_bytes = BMP_WIDTH / 8;

	uint8_t *dst = fp;
	/* the last line in bmp buffer is the line pix buffer */
	const uint8_t *src = bmp_buffer + BMP_FILE_SIZE;

	const uint8_t *bmp_buffer = gImage_logo800;

	src -= bmp_line_bytes;

	for (i = 0; i < BMP_HEIGHT; i++) {
		/* copy bmp buffer line by line */
		for (j = 0; j < BMP_WIDTH / 8; j++){
			*dst++ = *src++;
		}
		src -=2 * bmp_line_bytes;
	}
	
}

int draw_bitmap(uint8_t* bitmap, int x, int y, int width, int height)
{
	int ret = 0;
	int i, j;
	uint8_t* buf8 = NULL;

	if (width + x < 0 || height + y < 0 || x >= DISPLAY_SIZE_X || y >= DISPLAY_SIZE_Y)
		return -1;

	buf8 = atp_get_fb();

	if (DISPLAY_BPP == 16)
	{
		/* bmp BPP16 buffer generated by bmp2c.py */
		uint16_t* buf16;
		uint16_t* bmp16;
		buf16 = (uint16_t*)buf8;
		bmp16 = (uint16_t*)bitmap;

		for (j = y; j < y + height; j++)
		{
			for (i = x; i < x + width; i++)
			{
				*(buf16 + DISPLAY_SIZE_X * j + i) = *(bmp16 + width * (j - y) + (i - x));
			}
		}
	}
	else if (DISPLAY_BPP == 1) {
		/* 
		 * bmp BPP1 buffer generated by Image2lcd tools
		 * horization scan
		 * scan from top to bottom and from left to right
		 */
#if 0
		uint8_t k;
		for (j = y; j < y + height; j++)
		{
			k = 0;
			for (i = (x >> 3); i < ((x + width) >> 3); i++)
			{
				if (k < (width >> 3))
				{
					*(buf8 + LCD_BPP1_BYTESPERLINE * j + i) = *(bitmap + (width >> 3) * (j - y) + k);
				}else {
					*(buf8 + LCD_BPP1_BYTESPERLINE * j + i) = 0xFF;
				}
				k++;
			}
		}
#else
		uint8_t data;
		for (j = y; j < y + height; j++)
		{
			for (i = x; i <= x + width; i++)
			{
				data = bitmap_get_pixel(i - x, j - y, bitmap, width);
				videoram_set_pixel(i, j, data, buf8);
			}
		}
#endif
	}

	return ret;
}


/* Patch for Qemu FB driver */
/* in xxx_fb_update_display */
static void xxx_fb_update_display(void *opaque)
{
	... /* some code to get Qemu surface paramer */
			/* such as dst_line, pitch, width, height,and use Qemu api (translate guest os virtual memory addr to host virtual memory addr) to get GuestOS video ram ptr */

	/* Patch for support 1BPP emulation */
#ifdef FB_1BPP
#define GUEST_OS_DISPLAY_XRES	160
#define GUEST_OS_DISPLAY_YRES	160
	/* in guest os, use 1BPP to save memory */
#define HW_FBMEM_SIZE	 160 * 160 / 8
	int  i;
	const uint8_t* src = fbs.src_pixels;
	uint16_t*	dst = fbs.dst_pixels;

	int k;
	unsigned char byte;
	unsigned char bit;

	for (i = 0 ; i < HW_FBMEM_SIZE; i++)
	{
		byte = *src;
		bit = 0;
		for (k = 7; k >= 0; k--)
		{
			bit = ((byte >> k) & 1) ? 1 : 0;
			/* expand 1BPP to 16BPP pixel by pixel */
			if (bit == 1)
			{
				*dst++ = 0xFFFF;
			}
			else if (bit == 0)
			{
				*dst++ = 0x0000;
			}
		}
		src++;
	}
#endif
	
	dpy_update(surface->ds, rect.xmin, rect.ymin, rect.xmax-rect.xmin, rect.ymax-rect.ymin);
}
