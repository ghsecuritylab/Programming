/* xres = 160 */
/* yres = 160 */
uint8_t fp[160 * 160 / 8];

#define BMP_HEIGHT 80
#define BMP_WIDTH  80

/* bmp buffer read through fread */
void show_bitmap()
{
	/* target os need 1BPP */
#define BMP_FILE_SIZE (BMP_HEIGHT * BMP_WIDTH / 8)
	int i, j;
	uint8_t bmp_line_bytes = BMP_WIDTH / 8;

	uint8_t *dst = fp;
	/* the last line in bmp buffer is the line pix buffer */
	const uint8_t *src = bmp_buffer + BMP_FILE_SIZE;

	const uint8_t *bmp_buffer = gImage_logo800;

	src -= bmp_line_bytes;

	for (i = 0; i < BMP_HEIGHT; i++) {
		/* copy bmp buffer line by line */
		for (j = 0; j < BMP_WIDTH / 8; j++){
			*dst++ = *src++;
		}
		src -=2 * bmp_line_bytes;
	}
	
}

/* bmp buffer generate through Image2LCD */
/* Black = 1; White = 0, Keep consistent with Image2LCD */
/* But in Qemu,Black = 0; White = 1 */

void do_bitmap()
{
#define BMP_HEIGHT 80
#define BMP_WIDTH  80
	int i, j, k;

	const uint8_t *src = gImage_logo80;
	uint8_t fg = 1, d;
	uint8_t xor = 0xff;
	uint8_t *dst = fp;
	for (i = 0; i < BMP_HEIGHT; i++) 
	{
		for (j = 0; j < BMP_WIDTH; src++) 
		{
			d = *src ^ xor;
			unsigned char bit = 0;
			/* Image2LCD generate bmp buffer array, 
			 * Pixel sequence in BYTE:MSB...LSB(eg,pix0...pix7)
			 * Horization scan
			 * SCAN from top to bottom and from left to right
			 * 1BPP
			 * */
			for (k = 0; k <= 7; k++) 
			{
				bit = ((d >> k) & 1) ? 1 : 0;
				if (bit == 1)
				{
					*dst |= 1 << k;
				}
				else if (bit == 0)
				{
					*dst &= ~(1 << k);
				}
				j++;
			}
			dst++;
		}
		        
	}
}

void draw_bitmap(uint8_t* bmp, int x, int y, int width, int height)
{
	int ret = 0;
	int i, j;
	uint8_t* buf8 = NULL;

	if (width + x < 0 || height + y < 0 || x >= DISPLAY_SIZE_X || y >= DISPLAY_SIZE_Y)
		return -1;

	if (DISPLAY_BPP == 16)
	{
		/* bmp buffer generated by bmp2c.py */
		uint16_t* buf16;
		uint16_t* bmp16;
		buf16 = (uint16_t*)buf8;
		bmp16 = (uint16_t*)bitmap;

		for (j = y; j < y + height; j++)
		{
			for (i = x; i < x + width; i++)
			{
				*(buf16 + DISPLAY_SIZE_X * j + i) = *(bmp16 + width * (j - y) + (i - x));
			}
		}
	} else  if (DISPLAY_BPP == 1) {
//#define mono01 /* monochr. 1=black 0=white */
#define mono10 /* monochr. 1=white 0=black */
		uint8_t k;
		/* Assume bitmap height/width and (x,y) are both alignment with 8 */
		for (j = y; j < y + height; j++)
		{
			k = 0;
			for (i = x / 8; i < (x + width) / 8; i++)
			{
				//*(buf8 + DISPLAY_SIZE_X * j + i) = *(bmp8 + width * (j - y) / 8 + (i - x) / 8);

				if (k < width / 8)
				{
					*(buf8 + (DISPLAY_SIZE_X / 8) * j + i) = *(bitmap + width * (j - y) / 8 + k);
				}else
				{
					*(buf8 + (DISPLAY_SIZE_X / 8) * j + i) = 0xFF;
				}
				k++;
			}
		}
	}
	
}

/* Qemu Framebuffer Patch */
#ifdef BPP_1
#define GUEST_OS_DISPLAY_XRES	160
#define GUEST_OS_DISPLAY_YRES	160
	/* in guest os, use 1BPP to save memory */
#define HW_FBMEM_SIZE	 160 * 160 / 8
	int  i;
    const uint8_t* src1 = fbs.src_pixels;
    uint16_t*	dst1 = fbs.dst_pixels;

	/* Qemu Display:WHITE = 1, BLACK = 0 */
	uint8_t xor = 0x00;
	int k;
	unsigned char byte;
	unsigned char bit;

	for (i = 0 ; i < HW_FBMEM_SIZE; i++)
	{
		byte = *src1 ^ xor;
		bit = 0;
		for (k = 7; k >= 0; k--)
		{
			bit = ((byte >> k) & 1) ? 1 : 0;
			/* expand 1BPP to 16BPP pixel by pixel */
			if (bit == 1)
			{
				*dst1++ = 0xFFFF;				
			}
			else if (bit == 0)
			{
				*dst1++ = 0x0000;
			}
		}
		src1++;
	}
#endif




